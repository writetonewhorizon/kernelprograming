The C Language outlines :
 C Program Compilation
 Execution Process
 Tokens of C Program
 C Instructions
 Constants, Variables
 Identifiers and Keywords
 Primitive Data Types
 Structures – The Definition
 Structures – Declaration & Type
 Accessing Elements of Structure
 Range of Signed/Unsigned Data-types
 Efficient way of Printing Pointer
 Compiler Memory Allocation for Data-types
 Compiler Memory Allocation for Structures
 Data-type Alignments
 Compiler Memory Allocation for Unions
 Union – Data Corruption
 Practical Usage of Unions
 Practical Usage of Bitfields
 Bitfields Overflow
 Printing every byte of an Integer
 Enumeration
 Typedef Statements
 Practical example of Typedef Usage
 typedef’ing a Function Pointer
 Bit-Fields in Structure
Practical examples of Bitfield Usage
Structure Padding & Pitfalls
Programming Model & Memory Sizes
 Why Sizeof Int and Long is 4 or 8?
 Use of long long in 32-bit Architecture
Practical Example of long long
IA-32, IA-64, ILP-32, LP64, x86-64
 Array – Representation
 Array – Memory Allocation
 Array – Declaration & Initialization
 Two Dimensional Arrays

Pointers
 Accessing a Variable Through Pointer
 Pointer – Memory Allocation
 Pointer – Declaration & Initialization
 Pointer – Dereferencing
 Pointers & Arrays
 Character Arrays using Pointers
 Array of Character Pointers
 Memory Diagram – Array of Char Pointers
 Arrays as Pointers – a[i] == i[a]?
Constant Pointers
 Pointer Arithmetic
 String Handling Functions
 String Conversion Functions
 Efficient usage of sscanf()/sprintf()

Computing Basic
 Binary & Octal Systems
 Decimal & Hexadecimal Systems
Signed Representations in Memory
 Binary Shifts – Right & Left
 Sign Bits and Bit-Shift Operations
 Right Shift – Logical Vs Arithmetic Shift
 Bit-Shift Overflow
 ASCII Representations
 Endian-ness – Little Vs Big
 Endian-ness – Portability Issues
Operators
 Bitwise Operations
 Logical Operators – Short Circuit
 Bitwise Vs Logical Operations
 sizeof() operator
 Pitfalls/Issues with sizeof() usage
 Pointer Increment & Scaling
 Operator Precedence
 Operator Associativity
 True meaning of Associativity
 Examples of Precedence & Associativity
 Ternary Operator Associativity Rule
Data-type Conversion Rules
 Float to Int to Float Conversions
 Variadic functions & default promotion rules
 Printf Idiosynchracies
 Pointer Format Specifiers
 Signed Vs Unsigned – Pitfalls
Evaluation of i = ++i + ++i
 Evaluation of i = ++i + ++i + ++i
Concept of Sequence Points
 Example of Sequence Points

Storage Classes
 Storage Class Specifiers
 Scope of a Variable
 Register, Auto, Static, Extern
 Why Register Class and Practical Examples
 Automatic Variables and Stack
 Static Variables and Functions
 True meaning of Extern
 How to Use extern across Multiple Files with Examples
 Best Practices for Extern Usage
 Local/Block/Global Scope
 Nesting of Scope
 Lifetime of a Variable
 Linkage of a Variable
 What is Const?
Practical Examples of Const Qualifier
 Usage of Constant in library functions (libc)
 What is Volatile?
Practical Examples of Volatile Qualifier
 Const Volatile Together?
 Register Vs Volatile Performance?
Practical Examples of Const Volatile
 Pointer Aliasing
 What is Restrict Qualifier?
 Restrict Keyword and Compiler Optimization
Examples of Restrict Qualifier 
 
Memory
 Dynamic Memory Allocations
 malloc, calloc, realloc, free
 malloc Vs calloc
 Heap Memory
 Stack Memory – Pitfalls
 Dangling Pointers
 DMA – Errors
 Best Practices for malloc() & free()
 DMA – Unspecified Behaviour

Functions & Pointers
 Invoking Functions
 Passing Arguments to Functions
 Call by Value & Reference
 Is C call by Value?
 Is C call by Reference?
 Array as Function Argument
 Rules for Array Argument Passing
 Multi-dimensional Array Argument Passing
 Structure as Function Argument
 Static Vs Dynamic Runtime Environment
 Function Call and Runtime Stack
 Rules for Evaluation of Function Arguments
Memory Organization
 Code Segment
 Data Segment
 Heap Segment
 Stack Segment
 free space
 register space
 Stack Frames
 Calling Sequence
 View of Runtime Stack with Example
 Access to Local Variable in Stack
 Local Temporaries
 Function Pointers
 Declaration and Usage of Function Pointers
 Function Pointers as Function Parameters
 Practical Example of Function Pointers
 Pointer to an Integer Array
C Pointers Complexity Chart
 int **p
 int (*p)()
 int (*p)[]
 int *p()
 int *(*p[])()
 int *(**p)[]

Preprocessor
 Preprocessor – #include statements
 Multiple Inclusion of a Header File?
 Preprocessor – #define statements
 Preprocessor – Conditional Compilation
 Preprocessor – Nested Macros
 Preprocessor – Multiline Macros
 Preprocessor – Stringizer
 Preprocessor – Token Concatenation
 Preprocessor – Useful Directives
 Conditional Directives for Debugging
 Where Macros are Heavily Used
 Practical Examples of Macros
 Macros Pitfalls
 Macros Vs Enums
 Inline Functions
 Macros Vs Inline
 Inline Recursive Functions

Command Line Argument
 Environment Variables in C Programs
 Recursion Example
 Recursion Vs Iteration
 Code/Space/Time Complexity

Standard I/O Library
 Files & Streams
 Streams Buffers
 IO Buffers – Line Vs Full Vs No-Buffers
 Setting & Flushing Buffers
 File Access
 File Access Modes
 Sequential Vs Random Access
 Concept of File Offsets
 File Operation Errors
 End-of-File Condition?
 Return Values and Error Values
 Character Based File I/O
 Line Based File I/O
 Formatted File I/O
 Block File I/O
 Dangerous – gets() Vs fgets()
 File Random Access Methods 
 
Linux / Unix System Programming Training Course Outline

    Introduction to Unix
    Linux Layered Architecture
    Bootup Sequence
    File Tree & Types
    File Systems
    Super Block & Inode
    System Vs Function Calls
    System Call Sequence
    File descriptor table

    File Management
    File related System Calls
    File Control Operations
    File Locking
    fcntl() calls

    Process Management
    Mode of Execution
    Address Space
    Context Switching
    Process Structure & States
    Scheduling & Priority
    Process Creation & Exec
    fork()/exec() calls

    Memory Management
    Virtual Memory
    Paging & Swapping
    Memory Mapping
    Demand Paging

    Signals Vs. Interrupts
    Signals in Unix
    Receiving a Signal
    Handling a Signal
    Signal System Calls

    User Vs Daemon Process
    Characteristics of a Daemon
    Writing a Daemon
    Timers & Resource Limits
    Interval Timers
    High Resolution Timers
    System calls for Timers
    Resource Limits
    Hard Limit / Soft Limit 

	

    Why IPCs
    Type of IPC Mechanisms
    Primitive IPCs
    Pipes & FIFOs
    Full Duplex Pipes
    Persistence of Pipes & FIFOs
    Pros and Cons of Pipes/FIFOs
    Limitation of Pipes/FIFOs

    System V IPCs
    IPC Attributes
    IPC Persistence
    Kernel Limits for these IPCs

    Shared Memory
    Shared Memory System Calls
    Pros and Cons of Shared Memory

    Message Queues
    Message Queue System Calls
    Pros and Cons of Message Queues

    Semaphores
    Classical P() & V() Operations
    Binary & Counting Semaphores
    Semaphore System Calls
    Pros and Cons of Semaphores

    IPC Control Operations
    IPC Remova
Outline of Linux Internals and Debugging Training for System Administrator :
   Linux Kernel Introduction
   Linux System
   Linux Organization
   Linux Version
   Basic OS Concept
   Linux Filesystem
   File Types
   Processes & File Objects
   File Object Access
   The Process/Kernel Model
   Re-entrant Kernel
   Interleaved Kernel Control Paths
   Preemptive Kernel
   Preemptive Context Switch
   Synchronization
   Deadlock
   Memory Management

   Memory Addressing
   Logical, Linear & Physical Addresses
   Translating a Logical Address
   Segmentation in Linux
   Paging in Linux
   Large Pages
   Physical Page Extension(PAE)
   Hardware Cache
   Cache Coherency
   Translation Lookaside Buffers (TLBs)
   Linux 4 Table Paging Model
   Physical Memory Layout
   Kernel Physical Memory Variables
   Process Page Tables
   Kernel Page Tables
   TLB Management

   Processes in Linux Kernel
   Process
   Lightweight Process
   Threads & Thread Groups
   Process Descriptions
   The task_struct
   Linux Process States
   Thread Group Leader
   The Process List
   Waiting Processes
   Wait Queues
   Awakening Processes
   Process Creation
   Kernel Threads
   process 0 & Process 1
   Destroying Processes
   Process Removal

   Process Scheduling
   Process Preemption
   Quantum Duration
   Scheduling Policies
   Scheduling of Conventional Processes
   Dynamic Priority
   Realtime Processes
   Realtime Process Scheduling
   Runqueue Balancing in Multiprocessing Systems
   Scheduling Domains
   Load Balancing
   CPU Binding

   Signals in Linux
   Signal Related System Calls
   Signal Generation and Delivery
   Pending Signals
   Action Performed Upon Delivery
   Signals @ Multithreaded Application
   Delivering the Signal
   Catching the Signal
   Restarting System Calls
	Process Focus
   Viewing Processes
   Process Tree & Process Status
   Identifying System & Daemon Processes
   Foreground and Background Processes
   Tuning Process Scheduling
   Process Priority
   nice & renice commands
   Killing / Terminating a Processes
   Max Processes per User – ulimit
   Per Process Resource Limits
   Stack Sizes
   Core File Limits
   IPCs Consumption and Limits

   Process Internals
   Anatomy of a Process
   Process Map in Linux
   Memory Layout
   Code Segment
   Data Segment
   Stack Segment
   Heap Segment
   Decoding Process Map Lab

   System Focus
   Performance Monitoring & Troubleshooting
   System Status – Resource Consumption
   System Status – Memory Usage
   System Status – I/O Activity
   System Status – CPU Usage
   Resource Usage – Trends
   top, iostat, vmstat, sar commands
   Sample Programs to Consume CPU and Memory
   Memory Eater Lab
   CPU Loader Lab
   OOM Killer
   VM Overcommit Ratios

   Troubleshooting Methods
   Process Syscall Tracing – strace
   Process Libcall Tracing – ltrace
   Process Kernel/User Space Time Check
   Profiling Data using System & Library Traces

   GDB Debugging
   GDB Deep Dive Lab
   Debugging a Live Process
   Starting a Program with GDB
   Debugging a Memory/Core Dump
   Stack Traces
   Common Failures
   Failure Notifications
   Common Faults
   Segmentation Violation
   Stack Overflow
   Heap Overflow

   Linux Kernel Crash Dump Analysis
   Crash Dump Process
   How kexec / kdump Works
   Settinp up Kexec/Kdump
   crashkernel parameter
   Set up, Testing and Running Crash
   Crash Analysis 
   Advanced C Training Course Outline
Training on Linux & C Debugging Techniques :
    C program to Process
    Compilation Steps
    Preprocessor
    Compiler
    Assembler
    Linker / Loader
    GCC options
    Fixing Warnings in the Code
    Include Files
    Libraries
    Static Vs Dynamic Library
    Static Library Generation
    Dynamic Library Generation
    Linking with Libraries
    File Formats
    ELF Format
    Symbol Tables
    Anatomy of a Process
    Process Map
    Memory Layout
    Code Segment
    Data Segment
    Stack Segment
    Heap Segment
    Object Dump
    Stack Frames
    Mapping Assembly to C
    Managing Heap
    Pmap / Pstack
    Strace
    Debugging Tools
    GDB Debugger
    Debugging Running Process
    Core dump analysis
    Symbols & Optimizations
    Default Optimization Levels
    Common Failures
    Failure Notifications
    Common Faults
    Segmentation Violation
    Stack Overflow
    Heap Overflow
    Arithmetic Overflow
    Illegal code execution
    Stack Issue
    Endian-ness issue
    C library assertion
    Data Type mismatch
Linux Multithreaded Architecture and Programming :
    Introduction to Threads
    Parallelism
    Multi-cores
    Introduction to Thread
    Threads – Application
    User Level Threads (ULT)
    Advantage of ULT
    Disadvantage of ULT
    Kernel Level Threads (KLT)
    Advantage of KLT
    Disadvantage of KLT
    Threads Vs Processes
    Process Memory Layout
    Child Process Memory
    Threads Inside Processes
    Thread Memory Layout

    Thread Programming – I
    Introduction to Pthreads (POSIX Threads)
    Thread Creation
    Thread Termination
    Thread Id & Attributes
    Thread Joining & Detaching
    Thread Priorities
    Thread Cancellations
    Thread Cleanup Handling
    Passing Info to Threads

    Thread Programming – II
    Thread Synchronizations
    Mutual Exclusions
    Condition Variables
    Thread Safe Operations
    Thread Signal Handling
    Thread Signal Masking
    Issues @ Threads
    Races & Deadlocks
    Threads  & Process Resources
    Threads – File Handling
    Threads – IPC Handling

Linux Kernel Internals Training Course Outline :
Linux Kernel Introduction
Linux System
Linux Organization
Linux Version
Basic OS Concept
Linux N+1 System
Linux Filesystem
File Types
Processes & File Objects
File Object Access
The Process/Kernel Model
Re-entrant Kernel
Interleaved Kernel Control Paths
Preemptive Kernel
Preemptive Context Switch
Synchronization
Deadlock
Memory Management 	
Getting Started with Kernel :
Obtaining the Kernel Source
Installing the Kernel Source
Using Patches
The Kernel Source Tree
Building the Kernel
Configuring the Kernel
Efficient Kernel Building
Spawning Multiple Build Jobs
Installing the New Kernel
Understanding Kernel Programming
C Library or Standard Headers?
GNU C Extensions
Inline Functions
Inline Assembly
Branch Annotation
Memory Protection?
Floating Point?
Stack Sizes
Memory Addressing :
Logical, Linear & Physical Addresses
Translating a Logical Address
Segmentation in Linux
Paging in Linux
Large Pages
Physical Page Extension(PAE)
Hardware Cache
Cache Coherency
Translation Lookaside Buffers (TLBs)
Linux 4 Table Paging Model
Physical Memory Layout
Kernel Physical Memory Variables
Process Page Tables
Kernel Page Tables
TLB Management 	
Processes in Linux Kernel :
Process
Lightweight Process
Threads & Thread Groups
Process Descriptions
The task_struct
Linux Process States
Thread Group Leader
thread_info Structure
Kernel Stack Structure
The Process List
Waiting Processes
Wait Queues
Awakening Processes
Process Creation
clone() / fork() / vfork()
Kernel Threads
Process 0 & Process 1
Destroying Processes
exit_group() / _exit()
Process Removal
Kernel Synchronization :
Kernel Preemption
When Synchronization is Necessary
Interleaved Kernel Control Paths
When Synchronization is Not Necessary
Synchronization Constraints
Synchronization Primitives
Per-CPU Variables
Atomic Operations
Optimization & Memory Barriers
Spin Locks
Read/Write Spin Locks
Seqlocks
Read-Copy Update (RCU) Locks
Semaphores
Read/Write Semaphores
Local Interrupt Disabling
Disabling Deferrable Functions 	
Timing Measurements in Linux :
Clocks and Timer Circuits
Linux Timekeeping Architecture
The jiffies Variable
Updating System Statistics
Software Timers
Dynamic Timer List Structure
Timer List Data-Structure
Per-CPU Timer List
Delay Functions
udelay() and ndelay()
System Calls for POSIX Timers and Clocks
Process Scheduling :
Process Preemption
Quantum Duration
Scheduling Policies
Scheduling of Conventional Processes
Dynamic Priority
Realtime Processes
Realtime Process Scheduling
Runqueue Data Structure
Runqueue Balancing in Multiprocessing Systems
Scheduling Domains
Load Balancing
CPU Binding 	
Memory Management :
Page Frame / Page
Memory Zones
Reserved Page Frames
High Memory Page Frames
Temporary Kernel Mappings
Dynamic Contigous Page Allocation
Slab Allocator
Object Caches
Slab Cache Allocation
Object Allocation
General Purpose Allocation – kmalloc()
Non-contigous Memory Area Management
Process Address Space :
Kernel Address Space
Process Address Space
System Calls for Memory Region
brk(), execve(), _exit(), fork()
mmap(), mmap2(), munmap(),
shmat(), shmdt()
Page Faults
Valid & Invalid Addresses
The Memory Descriptor
The mem_struct Structure
Memory Regions
Linear Address Intervals – do_mmap()
Page Fault Exception Handling
Demand Paging
Copy on Write (COW)
Creating Process Address Space
Managing Heap Space 	
System Calls :
System Call Handler
Service Routines
Invoking a System Call
Leaving a System Call
Arguments to System Call
Arguments in Registers
Verifying the Arguments
Accessing Process Address Space
Exception Tables
Fixing Address Exceptions
Kernel Wrapper Routines
Signals in Linux :
Signal Related System Calls
Signal Generation and Delivery
Pending Signals
Action Performed Upon Delivery
Signals @ Multithreaded Application
Data Structures for Signal Handling
Delivering the Signal
Catching the Signal
Restarting System Calls 	
Linux Page Cache :
Page Cache Contents
Page Cache Requirements
The address_space Object
Block Buffers and Page Cache
The Buffer Head
Buffer Pages
Writing Dirty Pages to Disk
bdflush & pdflush
sync(), fsync() and fdatasync() calls
Page Frame Reclamation
Page Frame Reclaiming Algorithm
Unreclaimable pages
Swappable Pages
Syncable Pages
Discardable Pages
Design of the Algorithm
Reclaimation Tigger Points
Low on Memory
Periodic Reclaiming
The Out-of-memory Killer
Swapping Features 	
Linux Virtual Filesystem :
VFS Role in File Operations
VFS Supported Filesystem Classes
Common File Model
Process & VFS Object Interaction
VFS Data Structures
Super Block Object
Inode Object
File Object
Dentry Object
Processes and Files
The fd array
Constraints on a Process
File System Types
Filesystem Type Registration
Filesystem Handling
Mounting a Filesystem
Pathname Lookup
Reads & Writes
Other File Operations 

linux device driver outline :
    What is Kernel
    Linux System Architecture
    Linux Software Architecture
    Basic Kernel Services
    Linux Kernel Code
    What is a Device Driver
    Classes of Devices
    Device Driver Classification
    Concept of a Module
    Fundamental Concepts
    Kernel Module Vs Application
    Namespace
    Major & Minor Numbers
    Reserved Major Numbers
    Module Parameters
    Loading/Unloading Modules
    Current Process Information
    Kernel Memory Allocations
    Driver Entry Points
    Driver Switch Tables
    Module Init & Exit
    Device Registration
    Character Device Drivers
    File Structure
    File Operations Structure
    Driver-User Data Transfer
    Driver-Kernel Communication
    Driver-Device Communication
    Device File Creation
    Device File Control Operations
    Ioctl command numbers
    Capabilities & Restricted Operations
    Driver Usage Count
    Kernel Synchronization Mechanisms
    Introduction to Race Conditions
    Sources of Race Conditions
    Preemption – User & Kernel
    Preemption APIs
    Interrupt Handling APIs
    Semaphores
    Binary & Counting Semaphores
    Reader Writer Semaphores
    Semaphore APIs
    Mutexes
    Spinlocks
    Spinlock APIs
    Atomic Operations
    Seqlocks
    Seqlock APIs
    Completions
    Deadlock – Sources
    Deadlock Prevention
    Waitqueues
    Rules for Sleeping
    Waitqueue APIs
    Linux Kernel Tree
    Linux Source Code
    Linux Kernel Configuration
Linux Video Device Drivers:
   Display Architecture
   Linux-Video Subsystem
   Display Parameters
   The Frame Buffer API
   Frame Buffer Drivers
   Console Drivers
   Debugging Aspects
Linux Audio Device Drivers:
   Audio Architecture
   Linux-Sound Subsystem
   Device Example
   Debugging Aspects
   Writing a sample Audio Device Driver   
Linux I2C Device Drivers :  
   What’s I2C/SMBus?
   I2C Core
   Bus Transactions
   Device Examples
   I2C-dev
   Debugging Aspects
   Writing a sample I2C Device Driver
Linux SPI driver :
   What’s SPI bus?
   SPI Core
   Bus Transactions
   Device Examples
   SPI-dev
   Debugging Aspects
   Writing a sample SPI Device Driver
Linux USB Device Drivers    
    USB Architecture
    Linux-USB Subsystem
    Driver Data Structures
    Enumeration
    USB Device Example
    Class Drivers
    Debugging Aspects
    Writing a sample USB Device Driver
Linux Network Device Drivers : 
   Networking Driver Data Structures
   Communicating with Protocol Layers
   Buffer Management and Concurrency Control
   Network Device Example
   Network Throughput
   Debugging Aspects
   Writing a sample Network Device Drive
Linux Block Device Drivers :
    Storage Technologies
    Linux Block I/O Layer
    I/O Schedulers
    Block Driver Data Structures and Methods
    Block/Storage Device Example
    Advanced Topics
    Debugging
    Writing a sample Block Device Driver
Linux PCI Device Drivers : 
    The PCI Family
    Addressing and Identification
    Accessing PCI Regions
    Direct Memory Access
    PCI Device Example
    Debugging Aspects
    Writing a sample PCI Device Driver
Linux Kernel Debugging Training Course Outline :
   Intro to Kernel Debugging
   Kernel OOPS
   Kernel Hang

   Kernel Helpers for Debugging :
   Ksysmoops
   System.map
   /proc/kallsyms
   /proc/kcore
   Objdump – s vmlinux
   /var/log/messages
   Syslogd
   Magic SysRq

   Kernel Debuggers :
   gdb analysis of Live Kernel
   Limitations of gdb analysis
   kdb analysis of Live Kernel
   Limitations of kdb analysis
   kgdb analysis of Live Kernel
   Setting up kdb and kgdb
   kexec / kdump
   LKCD

   Linux Kernel Crash Dump Analysis :
   Crash Dump Process
   How kexec / kdump Works
   Settinp up Kexec/Kdump
   crashkernel parameter
   Set up, Testing and Running Crash
   Crash Analysis

   Hands-on Lab :
   Configuring the Kernel for Debugging
   Kernel Parameters for KDB and KGDB
   Building Kernel for Debugging
   Turning on Magic Sysrq Keys
   Debugging a Live Kernel using gdb, kdb and kgdb
   Printing Kernel Global Variables and Code
   Loading a Debug Module using kdb and kgdb
   Insert bug(s)
   make system hang
   Crash and Analyze 

kernel compilation :
#!/bin/sh
ARCH="x86"
CROSS_COMPILE="/opt/tooling/codesourcery/MGC-2014.05-45-i686-gcc-4.8.3/Sourcery_CodeBench_for_IA32_GNU_Linux/bin/i686-pc-linux-gnu-"

MODULES_INSTALL_PATH="/home/<userid>/Desktop/kernel_modules_lsim"

PROC_CORE=`nproc`
NUM_PARALLEL_JOB=8
if [ ! -z $PROC_CORE ] ; then
	echo "CPU cores : $PROC_CORE"
	NUM_PARALLEL_JOB=$(( $PROC_CORE * 2 ))
else
	echo "Cannot find the number of core..."
fi

echo "Compiling kernel..."
#All configure file will be under linux-2.6-imx/arch/x86/configs/.
make -j${NUM_PARALLEL_JOB} ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE x86_platform_production_defconfig
#make -j${NUM_PARALLEL_JOB} ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE menuconfig
#menuconfig is to add or delete some kernel support to the existing .config file.

#make -j${NUM_PARALLEL_JOB} ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE LOADADDR=0x12000000 uImage [zImage]
#image will be created to this dir. arch/arm/boot/uImage.
make -j${NUM_PARALLEL_JOB} ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE modules
#make -j${NUM_PARALLEL_JOB} ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE dtbs
echo "Installing modules..."
make modules_install ARCH=$ARCH CROSS_COMPILE=$CROSS_COMPILE INSTALL_MOD_PATH=$MODULES_INSTALL_PATH > /dev/mod_path
#By default installed modules dir is INSTALL_MOD_PATH =/lib/modules/[kernel version + CONFIG_LOCALVERSION]/

#gcc -Idir [options] [source files] [object files] [-o output file]
#-I-> include headres path
#-L-> include library path
#-g-> include gdb debugging symboles
#gcc -lpthread -I/home/dus5cob/samba/ccstg/dus5cob_AI_PRJ_SUZUKI_LINUX_15.0F25.vws/ai_osal_linux/components/inc/ /home/dus5cob/samba/ccstg/dus5cob_AI_PRJ_SUZUKI_LINUX_15.0F25.vws/ai_osal_linux/components/inc/dgram_service.c sim_adc.c -o sim_adc.test

platform drivers
A device class describes a type of device like an audio or network device
Each device class defines a set of semantics and a programming interface that devices of that class adhere to. Device drivers are the
implementation of that programming interface for a particular device on a particular bus.
A typical device class definition would look like:

struct device_class input_devclass = {
        .name       = "input",
        .add_device = input_add_device,
    .remove_device  = input_remove_device,
};

Each device class structure should be exported in a header file so it can be used by drivers, extensions and interfaces.
Device classes are registered and unregistered with the core using:
int devclass_register(struct device_class * cls);
void devclass_unregister(struct device_class * cls);

Each driver has a list of devices that it supports. The device class has a list of
drivers of that particular class. 

The platform device API

In the very early days, Linux users often had to tell the kernel where specific devices were to be found before their systems would work. In the absence of this information, the driver could not know which I/O ports and interrupt line(s) the device was configured to use. Happily, we now live in the days of busses like PCI which have discoverability built into them; any device sitting on a PCI bus can tell the system what sort of device it is and where its resources are. So the kernel can, at boot time, enumerate the devices available and everything Just Works.

Alas, life is not so simple; there are plenty of devices which are still not discoverable by the CPU. In the embedded and system-on-chip world, non-discoverable devices are, if anything, increasing in number. So the kernel still needs to provide ways to be told about the hardware that is actually present. "Platform devices" have long been used in this role in the kernel. This article will describe the interface for platform devices; it is meant as needed background material for a following article on integration with device trees.

Platform drivers

A platform device is represented by struct platform_device, which, like the rest of the relevant declarations, can be found in <linux/platform_device.h>. These devices are deemed to be connected to a virtual "platform bus"; drivers of platform devices must thus register themselves as such with the platform bus code. This registration is done by way of a platform_driver structure:

    struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t state);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
    };

At a minimum, the probe() and remove() callbacks must be supplied; the other callbacks have to do with power management and should be provided if they are relevant.

The other thing the driver must provide is a way for the bus code to bind actual devices to the driver; there are two mechanisms which can be used for that purpose. The first is the id_table argument; the relevant structure is:

    struct platform_device_id {
	char name[PLATFORM_NAME_SIZE];
	kernel_ulong_t driver_data;
    };

If an ID table is present, the platform bus code will scan through it every time it has to find a driver for a new platform device. If the device's name matches the name in an ID table entry, the device will be given to the driver for management; a pointer to the matching ID table entry will be made available to the driver as well. As it happens, though, most platform drivers do not provide an ID table at all; they simply provide a name for the driver itself in the driver field. As an example, the i2c-gpio driver turns two GPIO lines into an i2c bus; it sets itself up as a platform device with:

    static struct platform_driver i2c_gpio_driver = {
	.driver		= {
		.name	= "i2c-gpio",
		.owner	= THIS_MODULE,
	},
	.probe		= i2c_gpio_probe,
	.remove		= __devexit_p(i2c_gpio_remove),
    };

With this setup, any device identifying itself as "i2c-gpio" will be bound to this driver; no ID table is needed.

Platform drivers make themselves known to the kernel with:

    int platform_driver_register(struct platform_driver *driver);

As soon as this call succeeds, the driver's probe() function can be called with new devices. That function gets as an argument a platform_device pointer describing the device to be instantiated:

    struct platform_device {
	const char	*name;
	int		id;
	struct device	dev;
	u32		num_resources;
	struct resource	*resource;
	const struct platform_device_id	*id_entry;
	/* Others omitted */
    };

The dev structure can be used in contexts where it is needed - the DMA mapping API, for example. If the device was matched using an ID table entry, id_entry will point to the specific entry matched. The resource array can be used to learn where various resources, including memory-mapped I/O registers and interrupt lines, can be found. There are a number of helper functions for getting data out of the resource array; these include:

    struct resource *platform_get_resource(struct platform_device *pdev, 
					   unsigned int type, unsigned int n);
    struct resource *platform_get_resource_byname(struct platform_device *pdev,
					   unsigned int type, const char *name);
    int platform_get_irq(struct platform_device *pdev, unsigned int n);

The "n" parameter says which resource of that type is desired, with zero indicating the first one. Thus, for example, a driver could find its second MMIO region with:

    r = platform_get_resource(pdev, IORESOURCE_MEM, 1);

Assuming the probe() function finds the information it needs, it should verify the device's existence to the extent possible, register the "real" devices associated with the platform device, and return zero.

Platform devices

So now we have a driver for a platform device, but no actual devices yet. As was noted at the beginning, platform devices are inherently not discoverable, so there must be another way to tell the kernel about their existence. That is typically done with the creation of a static platform_device structure providing, at a minimum, a name which is used to find the associated driver. So, for example, a simple (fictional) device might be set up this way:

    static struct resource foomatic_resources[] = {
	{
		.start	= 0x10000000,
		.end	= 0x10001000,
		.flags	= IORESOURCE_MEM,
		.name	= "io-memory"
	},
	{
		.start	= 20,
		.end	= 20,
		.flags	= IORESOURCE_IRQ,
		.name	= "irq",
	}
    };

    static struct platform_device my_foomatic = {
	.name 		= "foomatic",
	.resource	= foomatic_resources,
	.num_resources	= ARRAY_SIZE(foomatic_resources),
    };

These declarations describe a "foomatic" device with a one-page MMIO region starting at 0x10000000 and using IRQ 20. The device is made known to the system with:

    int platform_device_register(struct platform_device *pdev);

Once both a platform device and an associated driver have been registered, the driver's probe() function will be called and the device will be instantiated. Registration of device and driver are usually done in different places and can happen in either order. A call to platform_device_unregister() can be used to remove a platform device.

Platform data

The above information is adequate to instantiate a simple platform device, but many devices are more complex than that. Even the simple i2c-gpio driver described above needs two additional pieces of information: the numbers of the GPIO lines to be used as i2c clock and data lines. The mechanism used to pass this information is called "platform data"; in short, one defines a structure containing the specific information needed and passes it in the platform device's dev.platform_data field.

With the i2c-gpio example, a full configuration looks like this:

    #include <linux/i2c-gpio.h>

    static struct i2c_gpio_platform_data my_i2c_plat_data = {
	.scl_pin	= 100,
	.sda_pin	= 101,
    };

    static struct platform_device my_gpio_i2c = {
	.name		= "i2c-gpio",
	.id		= 0,
	.dev = {
		.platform_data = &my_i2c_plat_data,
	}
    };

When the driver's probe() function is called, it can fetch the platform_data pointer and use it to obtain the rest of the information it needs.

Not everybody in the kernel community is enamored with platform devices; they seem like a bit of a hack used to encode information about specific hardware platforms into the kernel. Additionally, the platform data mechanism lacks any sort of type checking; drivers must simply assume that they have been passed a structure of the expected type. Even so, platform devices are heavily used, and that's unlikely to change, though the means by which they are created and discovered is changing. The way of the future appears to be device trees, which will be described in the following article.

driver-specific data structure consists of the following data elements:

? A cdev kernel abstraction element for character device drivers
? An instance of struct gpio structure describing a GPIO pin with configuration
? A variable indicating the state of a GPIO pin (low or high)
? A variable indicating the direction of a GPIO pin (input or output)
? A boolean variable used to enable or disable interrupt on a GPIO pin
? A flag indicating rising or falling edge trigger on a GPIO pin
? A counter for keeping track of the number of requests for interrupt
? A spinlock used for synchronization.

GPIO device driver to the kernel, it will be responsible for doing the following steps:
? Register a range of character device numbers
? Create a device class in /sys directory
? Claim GPIO pin resources
? Allocate memory for the per-device structure
? Initialize a spinlock to be used for synchronization
? Register character device to the kernel
? Create device nodes to expose GPIO resources to userspace
? Get current timestamp used for contact debouncing


Embedded Concepts, Linux Programming, Kernel and Code Porting to ARM, Char, Block, Network Device Drivers, USB drivers, Hands on with FriendlyARM and BeagleBone Kits

Linux Basics

•	Introduction to UNIX, Linux and GNU
•	Linux Introduction
•	Linux Commands and Shell Programming
•	Entering commands and creating variables
•	Important Linux Commands
•	Shell Basics, Script Basics
•	Working with file, directories and file attributes
•	Process, Variables, Substitutions
•	Flow Control – if, case statements
•	Loops – while, for loops and Parameters
•	Input/Output, Functions, Text Filtering
•	Signals, Pipes
•	Project Development in Shell Programming

 

 

Linux System Programming

•	Programming Linux in C
•	Linux Programs, GNU gcc compiler and tool chain
•	Applications, Header Files, Library Files, Static, Shared Libraries
•	Working with files,Linux File Structure
•	Low level file access – write, read, open
•	Standard I/O library, Formatted input/Output
•	Scanning directories- opendir, readir, seekdir,closedir
•	Linux Environemnt
•	Program arguments, Environment variables,Time,Date, Temporary files, Logging
•	Data management – managing memory, allocating and freeing memory, File locking
•	Databases – dbm database, dbm access functions
•	make command and Makefiles
•	Process and Signals
•	POSIX Threads
•	Semaphores, Shared Memory and Message Queues
•	Sockets Programming


Linux Kernel Module Programming

•	Introduction to the Linux kernel
•	Kernel source code
•	Configuring, compiling and booting the kernel
•	Linux kernel modules
•	Memory management and accessing hardware
•	Processes, scheduling, waiting for resources and interrupt management
•	Kernel debugging techniques
•	Lookaside Caches, Vmalloc,Lookaside Caches
•	I/O Ports and I/O Memory introduction
•	Using I/O Ports and I/O Memory
•	Using Digital I/O Ports
•	Loading modules on Demand
•	The /proc File System
•	Talking To Device Files
•	Blocking Processes
•	Replacing Printks
•	Interrupt Handling

 

Linux Device Drivers

•	Linux driver architecture
•	Classes of Devices and Modules
•	Char Drivers
•	Design a template
•	Major and Minor Numbers
•	Dynamic allocation of major numbers
•	File Operations, Block Drivers
•	Registering the Driver
•	Header File blk.h
•	Handling Requests - The Request Queue
•	Performing Actual Data Transfer
•	Removable Devices - check_media_change, Revalidation
•	Partitionable Devices - Partition Detection, Partition Detection Using initrd
•	Interrupt Driven Block Drivers
•	Network Drivers
•	net_device Structure - Visible Head, Hidden Fields
•	Socket Buffers
•	USB basics, Linux USB bus stack
•	USB driver classes
•	Interacting with USB devices from drivers
•	Driver hands-on


Embedded Linux

•	Introduction to embedded Linux
•	Embedded Linux system architecture
•	Cross-compiler tool-chains
•	Different tool-chains build procedures
•	Using pre-build cross tool-chain
•	Machine emulator and virtualizer
•	Using QEMU emulator for ARM
•	Supported hardware architectures
•	Using predefined config files
•	Cross-compiling the kernel for target
•	Understanding NAND/NOR flash
•	File system for flash
•	U-boot
•	Building U-boot for target
•	Booting target with U-boot
•	Transferring images to target using U-boot
•	Flashing kernel image and File System
•	Working on FriendlyARM and BeagleBone Boards

 

Kit,Parts provided during training

•	FriendlyARM mini2440 board,RaspberryPi board, Ethernet cable, USB cable, SDCard, 12 Inch Graphic LCD,Touch Panel, Fedora, Ubuntu Distro, Linux Toolchains

 







The linux kernel internels and debugging
01: Introduction 
02: Preliminaries 
03: Kernel Architecture I 
04: Kernel Programming Preview 
05: Modules 
06: Kernel Architecture II 
07: Kernel Initialization 
08: Kernel Configuration and Compilation 
09: System Calls 
10: Kernel Style and General Considerations 
11: Race Conditions and Synchronization Methods 
12: SMP and Threads 
13: Processes 
14: Process Limits and Capabilities ** 
15: Monitoring and Debugging 
16: The proc Filesystem ** 
17: kprobes 
18: Ftrace 
19: Perf 
20: Crash 
21: Kernel Core Dumps 
22: Scheduling Basics 
23: Completely Fair Scheduler (CFS) 
24: Timing Measurements 
25: Kernel Timers 
26: Memory Addressing 
27: Huge Pages 
28: Memory Allocation 
29: Process Address Space 
30: Disk Caches and Swapping 
31: Device Drivers** 
32: Signals 
33: Notifiers** 
34: CPU Frequency Scaling** 
35: Embedded Linux** 
36: Virtualization** 
Devloping linux device driver
1.	Introduction
2.	Preliminaries
3.	Device Drivers
4.	Modules I: Basics
5.	Character Devices
6.	Kernel Features
7.	Interrupts and Exceptions
8.	Modules II: Exporting, Licensing and Dynamic Loading
9.	Debugging Techniques
10.	Timing and Timers
11.	Race Conditions and Synchronization Methods
12.	ioctls
13.	Unified Device Model and sysfs
14.	Firmware
15.	Memory Management and Allocation
16.	Transferring Between User and Kernel Space
17.	Sleeping and Wait Queues
18.	Interrupt Handling: Deferrable Functions and User Drivers
19.	Hardware I/O
20.	PCI
21.	Platform Drivers**
22.	Device Trees**
23.	Direct Memory Access (DMA)
24.	Network Drivers I: Basics
25.	Network Drivers II: Data Structures
26.	Network Drivers III: Transmission and Reception
27.	Network Drivers IV: Selected Topics
28.	USB Drivers
29.	Memory Technology Devices**
30.	Power Management
31.	The Virtual File System
32.	I/O Scheduling
33.	Block Drivers
34.	Filesystems in User-Space (FUSE)**
35.	Journalling Filesystems**








Embedded linux development 
1.	Introduction
2.	Embedded and Real-Time Systems Concepts
3.	Cross-Development Environments: Goals and Needs
4.	Cross-Development: Auto-Build Tools
5.	Setting Up a Target Development Board
6.	Boot loaders and U-Boot
7.	Kernel Architecture Preview
8.	Kernel Source Tree Overview
9.	Kernel Programming Preview
10.	KBuild System
11.	Kernel Configuration, Compilation, Booting
12.	Modules
13.	Device Drivers**
14.	Device Trees**
15.	Target Filesystem Packaging
16.	Build Target Root Filesystem
17.	Root Filesystem Choices
18.	Configuring uClibc
19.	Build BusyBox Utility Suite
20.	Linker Scripts
21.	Kernel Monitoring and Debugging
22.	Right-Sizing
23.	Flash Memory Filesystems
24.	Compressed Filesystems
25.	Real-Time Extensions

Wayland
gst-launch-0.10 playbin2 uri=file://home/root/MVI_0135.MOV video-sink="lmwaylandsink dx=100 dy=100"
gst-launch-0.10 playbin2 uri=file://home/root/509853_0000_01_Quicktime_standard_MediaClip_01.mov video-sink="lmwaylandsink dw=990 dh=540 dx=20 dy=0 layer-id=4 surface-id=70"
gst-inspect lmwaylandsink





1. Boot PCSIM.
2. Do below configs:
systemctl start layer-management-wayland.service
sleep 1
export XDG_RUNTIME_DIR=/tmp
export LM_PLUGIN_PATH=/usr/lib/layermanager
LayerManagerControl create layer 3000 800 480
LayerManagerControl set screen 0 render order 3000
LayerManagerControl set layer 3000 visibility 1
LayerManagerControl get scene

3. Try below commands:
gst-launch playbin2 uri=file:///media/AAM_dev_sdb2/playable/oss_011_libtheora_1280x720_6M.mkv
gst-launch playbin2 uri=file:///media/AAM_dev_sdb2/playable/oss_011_libtheora_1280x720_6M.mkv video-sink="lmwaylandsink"
gst-launch videotestsrc ! lmwaylandsink

working :
systemctl start layer-management-wayland.service
sleep 1
export XDG_RUNTIME_DIR=/tmp
export LM_PLUGIN_PATH=/usr/lib/layermanager
LayerManagerControl set screen 0 render order 3000,10000
LayerManagerControl set layer 3000 visibility 1
 LayerManagerControl set layer 10000 opacity 0.2
LayerManagerControl set layer 3000 destination region 110 80 2000 1000 
gst-launch videotestsrc ! lmwaylandsink

h264 codec
/home/dus5cob/gitweb/H-264/videolan/x264/x264_0.148.2597+gite86f3a1-1_i386.deb
ffmpeg codec:

/home/dus5cob/gitweb/H-264/videolan/ffmpeg/ffmpeg_201508250700-git-1_i386.deb

gstremear plugins

export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH

 ./configure --prefix="$prefix" --disable-nls --disable-static --with-html-dir=/tmp/dump
 make 
 make install
 
  105
down vote
	
Create a backup of what packages are currently installed:
dpkg --get-selections > list.txt

Then (on another system) restore installations from that list:
dpkg --clear-selections
sudo dpkg --set-selections < list.txt

To get rid of stale packages
sudo apt-get autoremove

to reinstall and install :
sudo apt-get install --reinstall package


check the dependencies of packages in the repository:*
* apt-cache showpkg package-name

You can use apt-cache rdepends jetty to see what depends on jetty

This will show you all the information about the installed debian package:
* dpkg -I package.deb

list of installed debian package 
ls /var/cache/apt/archives


gst commands
gst-launch -v videotestsrc pattern=ball ! ximagesink
 gst-launch playbin uri=file:///home/dus5cob/samba/ccstg/LSIM_DEMO/SampleVideo_1080x720_1mb.flv
 gst-launch playbin uri=file:///home/dus5cob/samba/ccstg/LSIM_DEMO/MVI_2815_640x480_30fps.AVI
 gst-launch-0.10 playbin2 uri=http://docs.gstreamer.com/media/sintel_trailer-480p.webm
 

 32 bit OS
 mpeg-4 aac and h.264 decoder -> libavcodec54 
sudo apt-get -y install gstreamer0.10-pitfdll gstreamer0.10-ffmpeg gstreamer0.10-plugins-bad gstreamer0.10-plugins-bad-multiverse gstreamer0.10-plugins-ugly gstreamer0.10-plugins-ugly-multiverse

64 bit OS
sudo apt-get -y install gstreamer0.10-ffmpeg gstreamer0.10-plugins-bad gstreamer0.10-plugins-bad-multiverse gstreamer0.10-plugins-ugly gstreamer0.10-plugins-ugly-multiverse


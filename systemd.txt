
Systemd

systemd provides aggressive parallelization capabilities, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux control groups, supports snapshotting and restoring of the system state, maintains mount and auto-mount points and implements an elaborate transactional dependency-based service control logic.

systemd modules provides extensive commands list to diagnose start-up issues with scripts, services, target dependencies, device availability, sockets, system, slow startup, etc.
Goal

"Start as less as possible  and  Start more things in parallel."

This tutorial is meant as easy reference to identify and resolve these issues.

 
Icon

For purposes of learning - choose a software build with has some boot-up issues for effective learning and complete the tutorial. (e.g. AI_PRJ_PSA_RCC_LINUX_14.0F058)

 

 

    Systemd
    Basics
        Systemd Process sequence
        systemd-modules
        systemd-cgroups
        systemd configuration files
        uBoot Mode:
    Boot-up performance Analysis
        Boot-up time
        Boot-up for services
        Boot-up graphical chart
        Identify waiting Jobs
        Identify Failed Services
        Analysis Tools
            Process tree
            dmesg
            Systemd-Journal
            Detailed systemd-journal debugging messages
            tail systemd-journal messages on putty
            For more debugging tips:
        Service Dependency
        Boot-Up Complete

Basics
Systemd Process sequence

systemd is the first process (PID=1, /sbin/init) that is started up in the system which spawns kernel, then mounts file system, creates sockets, opens devices and spawns processes.

It creates trace system called systemd-journal which records kernel and component messages (routed from dmesg) into a separate journal logs file marked with component name.

And the core-dump from the Linux kernel is dumped to systemd-journal before transferring the callstack-dump information to TTFis Error Logs.

But Systemd-journal is mostly relevant at the start-up rather. After startup is complete i.e. Normal Execution, TTFis trace must be the right place to look at.
root@mx6q:/home/root/> ps -ax
Warning: bad ps syntax, perhaps a bogus '-'? See http://procps.sf.net/faq.html
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:07 /sbin/init
   98 ?        Ss     0:00 /lib/systemd/systemd-udevd
  118 ?        Ss     0:01 /lib/systemd/systemd-journald
  239 ?        Ss     0:02 /usr/bin/dbus-daemon --system --address=systemd: --no
  118 ?        Ss     0:01 /lib/systemd/systemd-journald
  144 ?        Ss     0:00 /bin/trace_journal -c
 
root@mx6q:/home/root/> ls -l /sbin/init
lrwxrwxrwx    1 root     root            22 Jan  1 00:07 /sbin/init -> /etc/alternatives/init
 
root@mx6q:/etc/> ls -l /etc/alternatives/init
lrwxrwxrwx    1 root     root            20 Jan  1 00:03 /etc/alternatives/init -> /lib/systemd/systemd

Bosch CCA Specific
Icon

If CCA components are spawned by OSAL_ProcessSpawn(), the threads are not spawned directly using Linux, request is handed over to systemd for spawing the process.

This way, all the processes are monitored by systemd e.g. procbase.out .

Also, LCM provides a libsystemdinterface_so.so which is responsible for providing the systemd watchdog and  status notification which is used by CCA for changing its internal states. If you are interested in setting up the order of execution of procbase group of processes, then refer LCM (More Info... ) for more details.
 root@mx6q:/home/root> pstree
systemd-modules

Systemd is the main process which controls the life cycle of the application. It mounts the file system, creates sockets and lauches the dependent applications.

Modules used by systemd are:

    systemd - systemd provides system information, cgroups, bootup analysis, etc.
    systemctl - provides the user to control the functionality of the systemd modules.
    journalctl - interprets the systemd traces logged in journal-traces and provides interface to control the journal related to each service.
    journald-trace - provides logger for systemd.
    udevd - mounts the devices, file system - fstab.
    dBus - this is used for Inter-process communication between systemd components.

Communication between systemd modules happens through dbus sockets...
 root@mx6q:/home/root> systemctl list-sockets -all
systemd-cgroups

Systemd will spawn the processes requested in the service file and they are grouped under cgroups named after the service file spawning the process and its associated resources.

e.g.   |-rbcm-procbase.service cgroup has the ownership of  (procbase_out.out, procvds2.out, procdiaglog_out.out, procdiagnosis_out.out, etc.).

This cgroup can be used to control the resources (cpu, mem, stack, etc) as a group rather than controlling (limiting) individual process using .service file fields.

systemd does not track threads within the process.
root@mx6q:/home/root/> systemd-cgls > systemd-cgls.txt
 root@mx6q:/home/root> vi systemd-cgls.txt ...
systemd configuration files

systemd service, target, mount, automount, device files are located in /lib/system/system. These are defined at the installation. Temporary configuration changes are made in /etc/systemd/ folder and these configurations override those under /lib/system/system. In case, you want to revert back the changes, then soft links/changes in /etc/system/system are simply removed and previous configuration remains. Some of the systemd commands also modify the configuration by under /etc/systemd/. So that original configuration is retained. Since /etc/systemd folder is modified, we might need read-write permissions to execute some commands/change configurations.
More Info...
uBoot Mode:

For analysing the systemd issues, take startup systemd traces by enabling u-boot mode in the debugger board.

In Normal mode, systemd traces are limited and does not show the reason for systemd startup failures or success as in-line traces.

We have to check them by using explicit systemctl commands later. This will load the CPU for TTY terminal operation due to putty command options.

Traces shows the detailed systemd traces:  systemd[1] as sequence of execution.
 systemd[1] traces... (...expand...)
Boot-up performance Analysis

Problem: The startup is very slow, it takes very long time to show the HMI screen/splash screens, some processes or modules are not responding or not ready yet.
Boot-up time

systemd-analyze – shows the time taken for complete boot up. CPU time usage break-up in terms of kernel space and user space. This summary can be the starting point for analysing boot up issues.

systemd-analyze time shows the same results as systemd-analyze
root@mx6q:/home/root/> systemd-analyze
 
Startup finished in 653ms (kernel) + 5829ms (userspace) = 6482ms
Boot-up for services

systemd-analyse blame – shows the time taken to startup individual services, sockets. It shows the current time spent in each service starting with top user.

This provides a high level indication about the CPU time usage of top services break-up till full boot-up. This can be starting point for analysis for minimizing the start-up usage.

Note: It does not indicate problem with the top user service in anyway.
root@mx6q:/home/root/> systemd-analyze blame
 root@mx6q:/home/root/> systemd-analyze blame
Boot-up graphical chart

systemd-analyse plot

This shows the startup time as a graphical representation. The generated file can be copied onto PC and opened in Mozilla Firefox browser.

There is no special configuration required to take systemd-analyse plot. It supported by default installation on PSA_RCC target.

These plots are basic plots with only information about service process status (started, in-progress, terminating) as a time plot.
root@mx6q:/home/root/> systemd-analyse plot > plot.svg

For more comprehensive logs compared to only process logs, you can take /sbin/bootchartd for details like: (Recommended for deeper analysis).

    Top CPU consumers
    IO utilization - read/Write
    CPU Utilization (Total + Individual service)
    CPU Wait - (Total + Individual service)
    Processes

Modify the /sbin/init/ to bootchartd service. This will modify the Init and slow down the boot up to some extent. (Note: Revert back after you have completed your analysis.)
root@mx6q:/home/root> ls -l /sbin/init
lrwxrwxrwx    1 root     root            22 Jan  1 00:07 /sbin/init -> /etc/alternatives/init
 
root@mx6q:/home/root>  cd /etc/alternatives
 
root@mx6q:/etc/alternatives>  ln -sf /lib/systemd/systemd-bootchart /sbin/init
 
root@mx6q:~/> ls -l /sbin/init
lrwxrwxrwx    1 root     root            30 Jan  1 01:04 /sbin/init -> /lib/systemd/systemd-bootchart
 
vi /etc/systemd/bootchart.conf

systemd-bootchart (here /sbin/bootchartd) will start an init replacement, which is configured on /etc/systemd/bootchart.conf (e.g. init=//lib/systemd/systemd), where you can configure the duration (frequency and number of samples) to get long duration traces of the system.
vi /etc/systemd/bootchart.conf
[Bootchart]
 
Samples=1800   # for 65 secs
Frequency=25
#Relative=no
#Filter=yes
#Output=<folder name, defaults to /run/log>
Init=/lib/systemd/systemd
#PlotMemoryUsage=yes?
#PlotEntropyGraph=no
#ScaleX=100
#ScaleY=20
root@mx6q:/home/root> sync
root@mx6q:/home/root> reboot
 
[  OK  ] Started RBCM PSA acl_speedcontrol.
[  OK  ] Started RBCM PSA acl_drive.
[   22.278955] Bluetooth: BNEP (Ethernet Emulation) ver 1.3
[   22.288223] Bluetooth: BNEP filters: protocol multicast
[   22.294602] Bluetooth: BNEP socket layer initialized
[   22.456813] Bluetooth: RFCOMM TTY layer initialized
[   22.462594] Bluetooth: RFCOMM socket layer initialized
[   22.470919] Bluetooth: RFCOMM ver 1.11
[  OK  ] Started "Start swu_common_teseo_app_out.out to get v...into registry".
 
systemd-bootchart wrote /run/log/bootchart-19700101-0000.svg
systemd-boochart: Warning: sample time overrun 52 times

Copy the .svg file to PC by using Winscp and Open the file in Mozilla Firefox Browser. (BGN : sample ).
Icon

root@mx6q:/home/root> ./enable_usb_dr_host_mode.sh 
# enable the ethernet port to target before connecting winscp.
copy bootchart-19700101-0000.svg file from path: /run/log/
This folder path is valid only for current boot, it will be deleted for next boot. 
change the path in configuration if you want to retain the file across boot-cycle.

For More options related to boot-chart rendering like memory, etc, same has to be  set inside /etc/systemd/bootchart.conf
Icon

Inside /etc/systemd/bootchart.conf, suppose if you do not set init link to systemd

Init=/lib/systemd/systemd
Then Linux system has no way to mount any file system and change your init program to systemd later. System is "lost" after startup. There is no way to recover from situation. Going into uBoot and setting recovery mode also does not work since rescue.target is read by systemd. Only One of the Option will be Flashing new installation or installing systemd package(must try!).

You can also change the shell by booting into uboot mode and changing init variable to shell. You can use the shell to mount or modify file system independent of systemd.
U-Boot > setenv xtargs $xtargs init=/bin/sh rw
U-Boot > boot
Sh#
Identify waiting Jobs

If you are not able to see the boot up is not finished even after long time, then it means that some of the services are not start-up properly, it is waiting for its dependents to start or service to be available.
root@mx6q:/home/root/> systemd-analyze
 
Bootup is not yet finished. Please try again later.

Analyse the list of systemd services started.
root@mx6q:/home/root/> systemctl
or
root@mx6q:/home/root/> systemctl list-units -a
 systemctl traces.......(..)

See JOB tab, if there is any service with “start” state, then it means these services are not able to proceed to start-up due to some preconditions failures OR use filtering options to just list-jobs to fetch the currently running jobs.
 root@mx6q:/lib/systemd/system> systemctl list-jobs

Here, the "waiting" jobs are executed only after "running" jobs are completed - In that case, check the list-jobs again after sometime.

It is not the case in above, analyse the reason for failure using system-journal logs: e.g: write-bdaddress.service
root@mx6q:/lib/systemd/system/> system status write-bdaddress.service
write-bdaddress.service - Writing Bluetooth Device Address to file
Loaded: loaded (/lib/systemd/system/write-bdaddress.service; enabled)
Active: inactive (dead)

Here write-bdaddress.service is loaded and enabled (in systemd daemon), but inactive (dead) that means systemd made an attempt to execute and some dependency did not launch properly and it is still in hanging state.

Go through write-bdaddress.service dependency:
 vi /lib/systemd/system/write-bdaddress.service

It is clear that write-bdaddress.service is dependent on sys-subsystem-bluetooth-devices-hci0.device device coming up. There is some reason for failure and jobs are hanging.
 systemd traces

After some, analysis of systemd startup logs (see uboot mode), it is clear that hci0 device starts later that this service getting started. so, we have to correct the dependencies.

It seems like hci0 Add bluetooth.target as dependency might solve the problem.
 vi /lib/systemd/system/write-bdaddress.service

Now, reload systemd configuration and reboot target. Reloading the daemon will update systemd internal data tree.
root@mx6q:/home/root> systemctl daemon-reload
root@mx6q:/home/root> reboot

write-bdaddress.service is launching properly not hanging any more.
 root@mx6q:/home/root> systemctl status write-bdaddress.service

If you want more detailed log of systemctl status, then you can go through journalctl logs by PID = 15872.
root@mx6q:/home/root/> journalctl _PID=15872
 root@mx6q:/home/root> journalctl _PID=15872

Hanging issues are solved by changing the order of service dependencies (After, Before, Requires, etc).

All the boot time optimizations are done making such observations and getting the depdendencies and adding only what is absolutely necessary.
Icon

It is possible that journal files are rotated during long boot-ups and multiple reboots and complete logs may not be available. You might want to increase journal log file size before starting the debugging process.

You can configure the journal logging using /etc/systemd/journald.conf

[Journal]

    Storage is auto, incase you want no logs so that system performance is not affected by systemd-journalling, then change it to "none"

#Storage=auto

    You can increase the size of journal logs so that no rotation of logs happens across reboots. You retain most of the logs for analysis.

SystemMaxUse=2M

    Direct logging in putty:

ForwardToConsole=yes

The journal logs shows the problems with starting up these failed resources, if dependent services or preconditions are not satisfied, etc.
Icon

In case PID for service is not available, then you will have to explicitly start the service and check the status again.
write-bdaddress.service - Writing Bluetooth Device Address to file
 Loaded: loaded (/lib/systemd/system/write-bdaddress.service; enabled)
 Active: inactive (dead)

If the write-bdaddress.service has failed, then restart the service again.
root@mx6q:/home/root/> systemctl start write-bdaddress.service
 
root@mx6q:/home/root/> systemctl status write-bdaddress.service

If the traces are not logged, there might be some other problem with the service (it might be dead, scripting error, configuration issues, etc). Also, check if the service file name is proper and present under /lib/systemd/system/
Identify Failed Services

Identify if there are any failed processes. (e.g. Carplay is failing.)
root@mx6q:/home/root/> systemctl --failed > systemctl.txt
root@mx6q:/home/root/> vi systemctl.txt

UNIT
	

LOAD
	

ACTIVE
	

SUB
	

JOB
	

DESCRIPTION

carplay.service
	

loaded
	

failed
	

failed
	

 
	

CarPlay

layer-man...t-wayland.service
	

loaded
	

failed
	

failed
	

 
	

Genivi Layer Management
Icon

If services are failing and not causing reboot of the target, that means it is not controlled by SPM supervision. It does not cause cyclic-reboots, but degrades boot-up performance by re-try and fail mechanisms. 

proc_base.out service controls the CCA applications and SPM supervision is applicable for only these application.

To identify these application, you can go through the process tree pstree or systemd-cgls
root@mx6q:/home/root/> systemd-cgls > cgls.txt
root@mx6q:/home/root/> vi cgls.txt
 proc_base ...(systemd-cgls)

Cyclic Reboots

If your target is going into cyclic reboots. then you might have to disable the watch-dog timers in the proc_base.out. Since systemd is controlling the proc_base.out startup,

watch-dog timer has be to be disabled in the /lib/systemd/system/rbcm-procbase.service

procbase_disable

To check if these services are having performance impact on the system boot-up process, we can mask these services and reboot the system.

Usually, Failed services are retried many times and it impacts the system boot-up time.

We need Read/Write permissions for enabling/disabling or masking/unmasking.
root@mx6q:/home/root/> rwrfs
root@mx6q:/home/root/> systemctl mask carplay
 
ln -s '/dev/null' '/etc/systemd/system/carplay.service'
root@mx6q:/home/root/> systemctl mask layer-management-wayland.service
 
ln -s '/dev/null' '/etc/systemd/system/layer-management-wayland.service'

OR it is also possible to disable the service:
root@mx6q:/home/root/> systemctl disable carplay.service
root@mx6q:/home/root/> systemctl disable layer-management-wayland.service
root@mx6q:/home/root/> reboot

If the issues is getting solved, that means this service is causing bootup performance issues.To get an idea what is the reason for failure for this service, enable TTFis trace with trace class for this component enabled.

You can also go through TTFis em_trace dumps to get the backtrace / callstack before the reset/failure.

Contact Feature Owners(FO) for more help with debugging this component.
Icon

It is possible to revert back the changes by using unmask. systemd will delete temporary link under /etc/systemd/system/.
root@mx6q:/home/root/> systemctl unmask carplay
 
rm '/etc/systemd/system/carplay.service'
 
#OR use enable in case you have used disable for this service.
 
root@mx6q:/home/root/> systemctl enable carplay
Icon

Difference between systemctl mask and systemctl disable :

mask - a soft link is made under /etc/systemd/system, so that service file in /lib/systemd/system/ is ignored and executes /dev/null/ link under /etc/systemd/system. (Executes dummy file)

disable - removes service file link from target dependency under /etc/systemd/system/multi-user.target.wants folder. So that multi-user.target does not start up this service. It is not affecting the system anymore.

             - if a service is disabled, and it is being referred by another services are dependencies, then this service is started up eventhough it is disabled. so, in a way it is just disabled or dormant / not masked (permanent change).

e.g. dependency graph:    multi-user.target.wants -> carplay.service -> layer-management-wayland.service

Inside multi-user.target.wants (installed by carplay itself) has to start carplay.service. Inside carplay.service it is asking for layer-management-wayland.service to be started first.

so, if you disable layer-management-wayland.service, it still gets invoked again from carplay.service - so, it does not stop the service with systemctl stop layer-management-wayland.service

The parent dependency must be disabled first and then the children services to correct this situation;  masking will anyway execute, but it is just calling dummy null file. so has no effect.

This scenario illustrates mechanism to isolate the problematic services in the dependency chain.

Note : These changes are persistent across reboot and requires RW mount for making changes. otherwise, changes are not applied.

In case you want to make this change only for current boot, then use --runtime option. (not required generally!)

 
Analysis Tools
Process tree

Alternatively, also check if the process mentioned in write-bdaddress.service file ExecStart=/opt/bosch/connectivity/bt_module/write_bdaddress.sh process is really started. This eliminates any issues related to systemd scripts.
 root@mx6q:/home/root> ps -ax (...)
dmesg

It is sometimes we can identify issue related to kernel or systemd by going through dmesg kernel log messages and solve the issues related to boot-up. These are comprehensive log messages from all the components.
root@mx6q:/home/root/> dmesg > dmesg.txt
root@mx6q:/home/root/> vi dmesg.txt
Systemd-Journal

dmesg logs are also captured in systemd-journal - advantage being, It is possible to filter the same echo messages by individual component by using systemd-journal logger.

This command provides complete log messages with component marking : mx6q systemd[1]:,   mx6q kernel:, mx6q exception-handler-config.sh, etc
root@mx6q:/home/root/> journalctl >journal.txt
root@mx6q:/home/root/> vi journal.txt

We can filter-out message by using PID filter if you are aware of the PID of the service (see process tree or systemd-cgls )
root@mx6q:/home/root/> journalctl _PID=15872
Detailed systemd-journal debugging messages

For Analysing the startup issues with systemd, you can change the trace level = debug
/etc/systemd/system.conf
root@mx6q:/home/root/> vi /etc/systemd/system.conf
 
[Manager]
LogLevel=debug
tail systemd-journal messages on putty
/etc/systemd/journald.conf
root@mx6q:/home/root/> vi /etc/systemd/journald.conf
 
ForwardToSyslog=yes

Current activity traces messages are logged on the putty. This is more useful than using clt commands to check problem with individual component. But, you can disable after identifying the problem area to avoid annoying messages.

Other Options in Journald is explained in detailed at:  Manipulate Systemd logs
For more debugging tips:

You can check the RAM, CPU usage. CAN startup issues. Resource issues, etc.

CAN Startup, top, pstree
Service Dependency

If the start-up is stuck due to some services hanging or waiting for  want of sub-services like resources, mounts, etc. then we have to identify the dependency for each service/target to know what service is stuck up and the reason behind it.

Then by solving the issues related to it, then we can complete the boot-up process. It also helps us to know the dependency and optimize those services or remove them altogether. There might be some services which are not really necessary, then we can remove such services from dependency list. OR some services might start-up early without the dependent service being available, this also results in delayed start-up.
root@mx6q:/home/root/> systemctl list-dependencies carplay.service > carplay.txt
root@mx6q:/home/root/> vi carplay.txt
 carplay ....(dependencies...)

We can also check the complete dependency list using multi-user.target as it is the multi-user target.
root@mx6q:/home/root/> systemctl list-dependencies multi-user.target

Or rather get complete dependency list to trace through all the children services using:
root@mx6q:/home/root/> systemctl list-dependencies -a multi-user.target

we can check the dependencies mentioned in the .target / .service configuration file with fields such as ( "Wants" , "WantedBy", "Requires", "RequiredBy", "Conflicts", "ConflictedBy", "Before", "After")

or just open /lib/systemd/system/multi-user.target or /etc/systemd/system/multi-user.target and see the contents.
root@mx6q:/home/root/> systemctl --no-pager show -p "Wants" multi-user.target
root@mx6q:/home/root/> systemctl show -p "Requires" multi-user.target
root@mx6q:/home/root/> systemctl show -p "WantedBy" multi-user.target
root@mx6q:/home/root/> systemctl show -p "RequiredBy" multi-user.target
root@mx6q:/home/root/> systemctl show -p "Conflicts" multi-user.target
root@mx6q:/home/root/> systemctl show -p "ConflictedBy" multi-user.target
root@mx6q:/home/root/> systemctl show -p "Before" multi-user.target

If you need comprehensive dump of the all dependencies in the systemd for complete system analysis. Then static dump can be extracted using this command:
root@mx6q:/home/root/> systemctl dump > systemctl-dump.txt
root@mx6q:/home/root/> vi systemctl-dump.txt
Boot-Up Complete

Start-up time might have reduced if these services had caused adverse boot-up issues.Check the systemd-analyze time.
root@mx6q:/home/root/> systemd-analyze
 Startup finished in 653ms (kernel) + 5829ms (userspace) = 6482ms

The Boot-up might not complete if it is still waiting for some service to complete or sub-services are waiting for some resources.
Icon

    If you are not able to completely boot-up, then repeat above instructions and mask other services to identify the actual reason for failure.

    If few services are still waiting, then go through the journal files or systemctl status for each waiting services and correct them or mask them to continue. Ensure that .target is successfully started up to complete the boot-up.

    Systemd is having re-try/time-out mechanism which tries to start-up failed services several times before giving up. (retry can be configured in .service file). This can influence the boot-up time.
    systemd-analyze time only shows the start-up time for systemd startup process not the HMI /Splash screen time. This must be recorded manually by using your Stop-watch Timer.

 To know the Final Target for booting up the system:
root@mx6q:/home/root/> systemctl get-default
 
multi-user.target

Default target is multi-user.target in our G3G projects because we have our own dedicated HMI. Graphical targets are applicable only for Ubuntu system.

 

Rescue Shell
Icon

But this can be checked in case your have set different init process such as rescue-boot.target or recovery mode targets.

In rescue shell, it is possible to disable the problematic drivers / dependencies and start the default.target. This way we can avoid cyclic reboots.

For more debugging option using rescue shell:

Rescue shell Debugging

Gen3_Rescue_Shell

Booting into EarlyConfiguration / Shell - Pre Systemd

    Goto UBoot mode and change init variable to shell. This is helpful if init variable is assigned to unbootable value and you want to rescue from this scenrio.
    U-Boot > setenv xtargs $xtargs init=/bin/sh rw
    U-Boot > boot

Useful links
Icon

    Related links
    G3G systemd-analyze
    FC_LCM-Componentdependencies
    Supervise systemd using eclipse gdb plug-in
    systemd for Applications and Services
    Early iMx Resets

Contact for this Page

Ravi Krishnamurthy (RBEI/ECP2)
